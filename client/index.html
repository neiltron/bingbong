<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Bingbong</title>
        <style>
            /* ============================================
               Design Tokens
               ============================================ */
            :root {
                /* Colors - Background */
                --color-bg-base: #000e14;
                --color-bg-surface: #00111a;
                --color-bg-elevated: #00141f;

                /* Colors - Border */
                --color-border: #2a2a3a;

                /* Colors - Text */
                --color-text-primary: #e0e0e0;
                --color-text-secondary: #999;
                --color-text-muted: #888;
                --color-text-inverse: #0a0a0f;
                --color-text-bright: #fff;

                /* Colors - Accent */
                --color-accent: #003d5c;
                --color-accent-hover: #003652;

                /* Colors - Semantic */
                --color-success: #6b9b6b;
                --color-error: #ff4444;
                --color-tool: #ff6b6b;

                /* Typography */
                --font-mono:
                    "SF Mono", "Monaco", "Inconsolata", "Roboto Mono", monospace;
                --font-size-xs: 0.75em;
                --font-size-sm: 0.8em;
                --font-size-base: 0.85em;
                --font-size-md: 0.9em;
                --font-size-lg: 1.5em;

                /* Spacing */
                --space-xs: 8px;
                --space-sm: 10px;
                --space-md: 15px;
                --space-lg: 20px;

                /* Radii */
                --radius-sm: 4px;
                --radius-md: 8px;
                --radius-full: 50%;

                /* Transitions */
                --transition-fast: 0.2s ease;
                --transition-base: 0.3s ease;

                /* Layout */
                --sidebar-width: 300px;
                --container-max: 1400px;
            }

            /* ============================================
               Reset & Base
               ============================================ */
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            :focus-visible {
                outline: 2px solid var(--color-accent);
                outline-offset: 2px;
            }

            @media (prefers-reduced-motion: reduce) {
                *,
                *::before,
                *::after {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                }
            }

            html {
                height: 100dvh;
            }

            body {
                font-family: var(--font-mono);
                background: var(--color-bg-base);
                color: var(--color-text-primary);
                height: 100dvh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            /* ============================================
               Accessibility
               ============================================ */
            .skip-link {
                position: absolute;
                top: -40px;
                left: 0;
                background: var(--color-accent);
                color: var(--color-text-inverse);
                padding: var(--space-xs) var(--space-md);
                z-index: 100;
                text-decoration: none;
                font-size: 14px;
                border-radius: 0 0 var(--radius-sm) 0;
            }

            .skip-link:focus {
                top: 0;
            }

            /* ============================================
               Layout
               ============================================ */
            .container {
                max-width: var(--container-max);
                margin: 0 auto;
                padding: var(--space-lg);
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }

            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: var(--space-lg) 0;
                border-bottom: 1px solid var(--color-border);
                margin-bottom: var(--space-lg);
            }

            .main-grid {
                display: grid;
                grid-template-columns: 1fr var(--sidebar-width);
                gap: var(--space-lg);
                flex: 1;
                min-height: 0;
            }

            .sidebar {
                display: flex;
                flex-direction: column;
                gap: var(--space-lg);
                height: 100%;
                min-height: 0;
            }

            @media (max-width: 900px) {
                html, body {
                    height: auto;
                    overflow: auto;
                }

                .container {
                    flex: none;
                    min-height: auto;
                }

                .main-grid {
                    grid-template-columns: 1fr;
                    flex: none;
                    min-height: auto;
                }

                #visualizer {
                    height: 300px;
                    flex: none;
                }

                .sidebar {
                    height: auto;
                }

                .sidebar .panel:nth-child(2),
                .sidebar .panel:nth-child(3) {
                    flex: none;
                }

                .sessions-list,
                .event-log {
                    max-height: 250px;
                    flex: none;
                }
            }

            /* ============================================
               Typography
               ============================================ */
            h1 {
                font-size: var(--font-size-lg);
                font-weight: 400;
                color: var(--color-text-bright);
            }

            h1 span {
                color: var(--color-accent);
            }

            .panel h2 {
                font-size: var(--font-size-md);
                font-weight: 500;
                color: var(--color-text-muted);
                margin-bottom: var(--space-md);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            /* ============================================
               Components - Status
               ============================================ */
            .status {
                display: flex;
                align-items: center;
                gap: var(--space-sm);
            }

            .status-dot {
                width: 10px;
                height: 10px;
                border-radius: var(--radius-full);
                background: var(--color-error);
                transition: background var(--transition-base);
            }

            .status-dot.connected {
                background: var(--color-success);
                box-shadow: 0 0 10px var(--color-success);
            }

            /* ============================================
               Components - Buttons
               ============================================ */
            .btn {
                border: none;
                border-radius: var(--radius-sm);
                cursor: pointer;
                font-family: inherit;
                font-size: 14px;
                transition: background var(--transition-fast);
            }

            .btn:disabled {
                cursor: not-allowed;
            }

            #connect-btn {
                background: var(--color-accent);
                color: var(--color-text-inverse);
                padding: var(--space-sm) var(--space-lg);
                border: none;
                border-radius: var(--radius-sm);
                cursor: pointer;
                font-family: inherit;
                font-size: 14px;
                transition: background var(--transition-fast);
            }

            #connect-btn:hover {
                background: var(--color-accent-hover);
            }

            #connect-btn:disabled {
                background: var(--color-bg-elevated);
                color: var(--color-text-muted);
                cursor: not-allowed;
            }

            .mute-btn {
                background: none;
                border: 1px solid var(--color-accent);
                color: var(--color-accent);
                padding: var(--space-xs) var(--space-md);
                border-radius: var(--radius-sm);
                cursor: pointer;
                font-family: inherit;
                font-size: 12px;
                transition: all var(--transition-fast);
            }

            .mute-btn:hover {
                background: var(--color-accent);
                color: var(--color-text-inverse);
            }

            .mute-btn.muted {
                border-color: var(--color-error);
                color: var(--color-error);
            }

            /* ============================================
               Components - Panel
               ============================================ */
            .panel {
                background: var(--color-bg-surface);
                border-radius: var(--radius-md);
                padding: var(--space-md);
                border: 1px solid var(--color-border);
                contain: content;
            }

            /* Controls panel: natural height, don't shrink */
            .sidebar .panel:first-child {
                flex-shrink: 0;
            }

            /* Sessions and Event Log panels: split remaining space */
            .sidebar .panel:nth-child(2),
            .sidebar .panel:nth-child(3) {
                flex: 1;
                min-height: 120px;
                display: flex;
                flex-direction: column;
            }

            /* ============================================
               Components - Visualizer
               ============================================ */
            .visualizer-section {
                background: var(--color-bg-surface);
                border-radius: var(--radius-md);
                padding: var(--space-lg);
                border: 1px solid var(--color-border);
                contain: layout paint;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }

            #visualizer {
                display: block;
                width: 100%;
                flex: 1;
                min-height: 200px;
                background: var(--color-bg-base);
                border-radius: var(--radius-sm);
            }

            /* ============================================
               Components - Sessions
               ============================================ */
            .sessions-list {
                display: flex;
                flex-direction: column;
                gap: var(--space-sm);
                flex: 1;
                overflow-y: auto;
                min-height: 0;
            }

            .session-item {
                display: flex;
                align-items: center;
                gap: var(--space-sm);
                padding: var(--space-sm);
                background: var(--color-bg-elevated);
                border-radius: var(--radius-sm);
            }

            .session-color {
                width: 12px;
                height: 12px;
                border-radius: var(--radius-full);
                flex-shrink: 0;
            }

            .session-info {
                flex: 1;
                min-width: 0;
            }

            .session-id {
                font-size: var(--font-size-base);
                color: var(--color-text-bright);
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .session-meta {
                font-size: var(--font-size-xs);
                color: var(--color-text-secondary);
            }

            .pan-indicator {
                width: 60px;
                height: 6px;
                background: var(--color-border);
                border-radius: 3px;
                position: relative;
            }

            .pan-dot {
                position: absolute;
                width: 8px;
                height: 8px;
                background: var(--color-accent);
                border-radius: var(--radius-full);
                top: -1px;
                transform: translateX(-50%);
            }

            /* ============================================
               Components - Event Log
               ============================================ */
            .event-log {
                flex: 1;
                overflow-y: auto;
                font-size: var(--font-size-sm);
                min-height: 0;
            }

            .event-item {
                display: flex;
                align-items: baseline;
                gap: var(--space-xs);
                padding: var(--space-xs);
                border-bottom: 1px solid var(--color-bg-elevated);
                animation: fadeIn var(--transition-base);
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .event-type {
                color: var(--color-accent);
                font-weight: 500;
            }

            .event-tool {
                color: var(--color-tool);
                margin-left: var(--space-xs);
            }

            .event-time {
                color: var(--color-text-secondary);
                font-size: var(--font-size-md);
                margin-left: auto;
            }

            /* ============================================
               Components - Controls
               ============================================ */
            .controls {
                display: flex;
                flex-direction: column;
                gap: var(--space-md);
            }

            .control-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .control-row label {
                font-size: var(--font-size-base);
                color: var(--color-text-muted);
            }

            input[type="range"] {
                width: 100px;
                accent-color: var(--color-accent);
            }

            /* ============================================
               Components - Empty State
               ============================================ */
            .empty-state {
                color: var(--color-text-muted);
                font-style: italic;
                text-align: center;
                padding: var(--space-lg);
            }

            /* ============================================
               Components - Spatial Canvas
               ============================================ */
            .spatial-container {
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            .spatial-container canvas {
                display: block;
                width: 100%;
                height: 100%;
            }

            .source-circle {
                position: absolute;
                transform: translate(-50%, -50%);
                width: 56px;
                height: 56px;
                border-radius: 50%;
                background: var(--color-bg-elevated);
                border: 2px solid var(--session-color, var(--color-border));
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                cursor: grab;
                user-select: none;
                transition: box-shadow 0.2s, transform 0.1s, opacity 0.3s;
                z-index: 10;
                touch-action: none;
            }

            .source-circle:hover {
                box-shadow: 0 0 15px color-mix(in srgb, var(--session-color) 50%, transparent);
            }

            .source-circle.selected {
                border-width: 3px;
                box-shadow: 0 0 20px color-mix(in srgb, var(--session-color) 70%, transparent);
            }

            .source-circle.dragging {
                cursor: grabbing;
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                z-index: 100;
            }

            .source-circle.disconnected {
                opacity: 0.4;
                border-style: dashed;
                filter: grayscale(0.7);
                pointer-events: none;
            }

            .source-icon {
                font-size: 18px;
                color: var(--session-color);
                line-height: 1;
            }

            .source-label {
                font-size: 9px;
                color: var(--color-text-secondary);
                margin-top: 2px;
                white-space: nowrap;
                max-width: 48px;
                overflow: hidden;
                text-overflow: ellipsis;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <a href="#main-content" class="skip-link">Skip to main content</a>
        <div class="container">
            <header>
                <h1><span>Bingbong</span></h1>
                <div class="status">
                    <div
                        class="status-dot"
                        id="status-dot"
                        role="status"
                        aria-label="Connection status: disconnected"
                    ></div>
                    <span id="status-text">Disconnected</span>
                    <button id="connect-btn">Connect</button>
                </div>
            </header>

            <main class="main-grid" id="main-content">
                <div class="visualizer-section">
                    <div class="spatial-container" id="spatial-container">
                        <canvas
                            id="visualizer"
                            role="img"
                            aria-label="Spatial audio visualization showing source positions"
                        >
                            <p>
                                Spatial audio field with draggable source positions
                            </p>
                        </canvas>
                    </div>
                </div>

                <aside
                    class="sidebar"
                    aria-label="Controls and session information"
                >
                    <section class="panel" aria-labelledby="controls-heading">
                        <h2 id="controls-heading">Controls</h2>
                        <div class="controls">
                            <div class="control-row">
                                <label for="volume">Master Volume</label>
                                <input
                                    type="range"
                                    id="volume"
                                    min="0"
                                    max="100"
                                    value="70"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="70"
                                />
                            </div>
                            <div class="control-row">
                                <label for="reverb">Reverb</label>
                                <input
                                    type="range"
                                    id="reverb"
                                    min="0"
                                    max="100"
                                    value="30"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="30"
                                />
                            </div>
                            <button
                                class="mute-btn"
                                id="mute-btn"
                                aria-pressed="false"
                            >
                                Mute
                            </button>
                            <button
                                class="mute-btn"
                                id="reset-layout-btn"
                                style="margin-left: auto;"
                            >
                                Reset Layout
                            </button>
                        </div>
                    </section>

                    <section class="panel" aria-labelledby="sessions-heading">
                        <h2 id="sessions-heading">Active Sessions</h2>
                        <div
                            class="sessions-list"
                            id="sessions-list"
                            role="list"
                            aria-live="polite"
                        >
                            <div class="empty-state" role="listitem">
                                No active sessions
                            </div>
                        </div>
                    </section>

                    <section class="panel" aria-labelledby="eventlog-heading">
                        <h2 id="eventlog-heading">Event Log</h2>
                        <div
                            class="event-log"
                            id="event-log"
                            role="log"
                            aria-live="polite"
                            aria-atomic="false"
                        >
                            <div class="empty-state">Waiting for events...</div>
                        </div>
                    </section>
                </aside>
            </main>
        </div>

        <script>
            // ============================================
            // Configuration
            // ============================================
            const WS_URL = `ws://${location.host}/ws`;

            // Helper to create elements safely
            function createElement(tag, attrs = {}, children = []) {
                const el = document.createElement(tag);
                for (const [key, value] of Object.entries(attrs)) {
                    if (key === "style" && typeof value === "object") {
                        Object.assign(el.style, value);
                    } else if (key.startsWith("data-")) {
                        el.dataset[key.slice(5)] = value;
                    } else {
                        el.setAttribute(key, value);
                    }
                }
                for (const child of children) {
                    if (typeof child === "string") {
                        el.appendChild(document.createTextNode(child));
                    } else if (child) {
                        el.appendChild(child);
                    }
                }
                return el;
            }

            // Sound mappings - notes and characteristics for each event/tool
            const SOUND_CONFIG = {
                // Event types
                SessionStart: {
                    note: "C4",
                    duration: 0.4,
                    type: "sine",
                    gain: 0.4,
                },
                SessionEnd: {
                    note: "G3",
                    duration: 0.5,
                    type: "sine",
                    gain: 0.3,
                },
                Stop: {
                    notes: ["C5", "E5", "G5"],
                    duration: 0.6,
                    type: "sine",
                    gain: 0.5,
                },
                SubagentStop: {
                    note: "E5",
                    duration: 0.3,
                    type: "triangle",
                    gain: 0.35,
                },
                PreCompact: {
                    note: "D4",
                    duration: 0.2,
                    type: "sawtooth",
                    gain: 0.15,
                },

                // Tool-specific sounds (for PreToolUse/PostToolUse)
                tools: {
                    Read: {
                        note: "A4",
                        duration: 0.08,
                        type: "sine",
                        gain: 0.15,
                    },
                    Write: {
                        note: "E4",
                        duration: 0.12,
                        type: "triangle",
                        gain: 0.25,
                    },
                    Edit: {
                        note: "D4",
                        duration: 0.1,
                        type: "triangle",
                        gain: 0.2,
                    },
                    Bash: {
                        note: "F3",
                        duration: 0.15,
                        type: "square",
                        gain: 0.12,
                    },
                    Task: {
                        notes: ["G4", "B4"],
                        duration: 0.25,
                        type: "sine",
                        gain: 0.35,
                    },
                    Grep: {
                        note: "B4",
                        duration: 0.06,
                        type: "sine",
                        gain: 0.1,
                    },
                    Glob: {
                        note: "C5",
                        duration: 0.06,
                        type: "sine",
                        gain: 0.1,
                    },
                    WebFetch: {
                        note: "F#4",
                        duration: 0.15,
                        type: "sine",
                        gain: 0.2,
                    },
                    WebSearch: {
                        note: "G#4",
                        duration: 0.2,
                        type: "sine",
                        gain: 0.25,
                    },
                    TodoWrite: {
                        note: "A3",
                        duration: 0.1,
                        type: "triangle",
                        gain: 0.15,
                    },
                    default: {
                        note: "C4",
                        duration: 0.1,
                        type: "sine",
                        gain: 0.15,
                    },
                },
            };

            // Note to frequency mapping
            const NOTE_FREQ = {
                C3: 130.81,
                D3: 146.83,
                E3: 164.81,
                F3: 174.61,
                "F#3": 185.0,
                G3: 196.0,
                "G#3": 207.65,
                A3: 220.0,
                B3: 246.94,
                C4: 261.63,
                D4: 293.66,
                E4: 329.63,
                F4: 349.23,
                "F#4": 369.99,
                G4: 392.0,
                "G#4": 415.3,
                A4: 440.0,
                B4: 493.88,
                C5: 523.25,
                D5: 587.33,
                E5: 659.25,
                F5: 698.46,
                G5: 783.99,
                A5: 880.0,
                B5: 987.77,
            };

            // ============================================
            // Audio Engine
            // ============================================
            class AudioEngine {
                constructor() {
                    this.ctx = null;
                    this.masterGain = null;
                    this.convolver = null;
                    this.reverbGain = null;
                    this.dryGain = null;
                    this.muted = false;
                    this.volume = 0.7;
                    this.reverbAmount = 0.3;
                    this.sessionPanners = new Map(); // PannerNode per session
                }

                async init() {
                    if (this.ctx) return;

                    this.ctx = new (
                        window.AudioContext || window.webkitAudioContext
                    )();

                    // Create master gain
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = this.volume;

                    // Create reverb path
                    this.convolver = this.ctx.createConvolver();
                    this.reverbGain = this.ctx.createGain();
                    this.reverbGain.gain.value = this.reverbAmount;

                    this.dryGain = this.ctx.createGain();
                    this.dryGain.gain.value = 1 - this.reverbAmount;

                    // Generate impulse response for reverb
                    await this.createReverbImpulse();

                    // Connect: source -> [dry + reverb] -> master -> output
                    this.convolver.connect(this.reverbGain);
                    this.reverbGain.connect(this.masterGain);
                    this.dryGain.connect(this.masterGain);
                    this.masterGain.connect(this.ctx.destination);

                    // Set listener at origin for 3D audio
                    const listener = this.ctx.listener;
                    if (listener.positionX) {
                        listener.positionX.setValueAtTime(0, this.ctx.currentTime);
                        listener.positionY.setValueAtTime(0, this.ctx.currentTime);
                        listener.positionZ.setValueAtTime(0, this.ctx.currentTime);
                        listener.forwardX.setValueAtTime(0, this.ctx.currentTime);
                        listener.forwardY.setValueAtTime(0, this.ctx.currentTime);
                        listener.forwardZ.setValueAtTime(-1, this.ctx.currentTime);
                        listener.upX.setValueAtTime(0, this.ctx.currentTime);
                        listener.upY.setValueAtTime(1, this.ctx.currentTime);
                        listener.upZ.setValueAtTime(0, this.ctx.currentTime);
                    }
                }

                async createReverbImpulse() {
                    const duration = 2;
                    const decay = 2;
                    const sampleRate = this.ctx.sampleRate;
                    const length = sampleRate * duration;
                    const impulse = this.ctx.createBuffer(
                        2,
                        length,
                        sampleRate,
                    );

                    for (let channel = 0; channel < 2; channel++) {
                        const data = impulse.getChannelData(channel);
                        for (let i = 0; i < length; i++) {
                            data[i] =
                                (Math.random() * 2 - 1) *
                                Math.pow(1 - i / length, decay);
                        }
                    }

                    this.convolver.buffer = impulse;
                }

                setVolume(value) {
                    this.volume = value;
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.muted ? 0 : value;
                    }
                }

                setReverb(value) {
                    this.reverbAmount = value;
                    if (this.reverbGain && this.dryGain) {
                        this.reverbGain.gain.value = value;
                        this.dryGain.gain.value = 1 - value * 0.5;
                    }
                }

                toggleMute() {
                    this.muted = !this.muted;
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.muted
                            ? 0
                            : this.volume;
                    }
                    return this.muted;
                }

                createPannerForSession(sessionKey) {
                    if (!this.ctx) return null;
                    if (this.sessionPanners.has(sessionKey)) {
                        return this.sessionPanners.get(sessionKey);
                    }

                    const panner = this.ctx.createPanner();
                    panner.panningModel = 'HRTF';
                    panner.distanceModel = 'inverse';
                    panner.refDistance = 1;
                    panner.maxDistance = 10;
                    panner.rolloffFactor = 1.5; // Dramatic falloff
                    panner.coneInnerAngle = 360;
                    panner.coneOuterAngle = 360;

                    // Connect to dry/wet paths
                    panner.connect(this.dryGain);
                    panner.connect(this.convolver);

                    this.sessionPanners.set(sessionKey, panner);
                    return panner;
                }

                updatePannerPosition(sessionKey, normX, normY) {
                    const panner = this.sessionPanners.get(sessionKey);
                    if (!panner || !this.ctx) return;

                    // Convert normalized coords (0-1) to 3D space (-5 to +5)
                    const x = (normX - 0.5) * 10;
                    const z = (0.5 - normY) * 10; // Y inverted for front/back

                    panner.positionX.setValueAtTime(x, this.ctx.currentTime);
                    panner.positionY.setValueAtTime(0, this.ctx.currentTime);
                    panner.positionZ.setValueAtTime(z, this.ctx.currentTime);
                }

                removePannerForSession(sessionKey) {
                    const panner = this.sessionPanners.get(sessionKey);
                    if (panner) {
                        panner.disconnect();
                        this.sessionPanners.delete(sessionKey);
                    }
                }

                playSound(config, pan = 0, sessionKey = null) {
                    if (!this.ctx || this.muted) return;

                    const now = this.ctx.currentTime;
                    const notes = config.notes || [config.note];

                    // Use session's 3D panner if available, otherwise create stereo panner
                    const sessionPanner = sessionKey ? this.sessionPanners.get(sessionKey) : null;

                    notes.forEach((note, i) => {
                        const freq = NOTE_FREQ[note] || 440;
                        const delay = i * 0.05; // Slight delay for chords

                        // Create oscillator
                        const osc = this.ctx.createOscillator();
                        osc.type = config.type || "sine";
                        osc.frequency.value = freq;

                        // Create gain for envelope
                        const gainNode = this.ctx.createGain();
                        gainNode.gain.value = 0;

                        // Connect through session's 3D panner or fallback to stereo
                        osc.connect(gainNode);
                        if (sessionPanner) {
                            // Route through session's pre-configured PannerNode
                            gainNode.connect(sessionPanner);
                        } else {
                            // Fallback: create stereo panner for non-session sounds
                            const panner = this.ctx.createStereoPanner();
                            panner.pan.value = pan;
                            gainNode.connect(panner);
                            panner.connect(this.dryGain);
                            panner.connect(this.convolver);
                        }

                        // Envelope
                        const attackTime = 0.01;
                        const releaseTime = config.duration * 0.7;
                        const gain = config.gain || 0.2;

                        gainNode.gain.setValueAtTime(0, now + delay);
                        gainNode.gain.linearRampToValueAtTime(
                            gain,
                            now + delay + attackTime,
                        );
                        gainNode.gain.exponentialRampToValueAtTime(
                            0.001,
                            now + delay + config.duration,
                        );

                        // Start and stop
                        osc.start(now + delay);
                        osc.stop(now + delay + config.duration + 0.1);
                    });
                }

                playEvent(event) {
                    const { event_type, tool_name, pan, machine_id, session_id } = event;

                    // Build session key for 3D panner lookup
                    const sessionKey = machine_id && session_id
                        ? `${machine_id}:${session_id}`
                        : null;

                    // Get sound config based on event type
                    let config;

                    if (
                        event_type === "PreToolUse" ||
                        event_type === "PostToolUse"
                    ) {
                        // Use tool-specific sound
                        config =
                            SOUND_CONFIG.tools[tool_name] ||
                            SOUND_CONFIG.tools.default;

                        // Make PostToolUse slightly different (higher pitch)
                        if (event_type === "PostToolUse" && config.note) {
                            const noteIndex = Object.keys(NOTE_FREQ).indexOf(
                                config.note,
                            );
                            if (noteIndex > 0) {
                                config = {
                                    ...config,
                                    note:
                                        Object.keys(NOTE_FREQ)[noteIndex + 1] ||
                                        config.note,
                                };
                            }
                        }
                    } else {
                        // Use event type sound
                        config =
                            SOUND_CONFIG[event_type] ||
                            SOUND_CONFIG.tools.default;
                    }

                    this.playSound(config, pan || 0, sessionKey);
                }
            }

            // ============================================
            // Position Manager
            // ============================================
            class PositionManager {
                constructor() {
                    this.positions = new Map();
                    this.loadFromStorage();
                    this.cleanupStale();
                }

                storageKey(sessionKey) {
                    return `bingbong:position:${sessionKey}`;
                }

                loadFromStorage() {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key?.startsWith('bingbong:position:')) {
                            try {
                                const data = JSON.parse(localStorage.getItem(key));
                                const sessionKey = key.replace('bingbong:position:', '');
                                this.positions.set(sessionKey, data);
                            } catch (e) { /* ignore corrupt data */ }
                        }
                    }
                }

                savePosition(sessionKey, x, y) {
                    const data = { x, y, savedAt: new Date().toISOString() };
                    this.positions.set(sessionKey, data);
                    localStorage.setItem(this.storageKey(sessionKey), JSON.stringify(data));
                }

                getPosition(sessionKey, index = 0) {
                    const saved = this.positions.get(sessionKey);
                    if (saved) return { x: saved.x, y: saved.y };
                    return this.autoAssign(index);
                }

                hasPosition(sessionKey) {
                    return this.positions.has(sessionKey);
                }

                autoAssign(index) {
                    // First source at center
                    if (index === 0) return { x: 0.5, y: 0.5 };

                    // Golden angle spiral for subsequent sources
                    const angle = (index * 137.5) * (Math.PI / 180);
                    const ring = Math.ceil(Math.sqrt(index));
                    const radius = 0.15 + (ring * 0.1);

                    return {
                        x: Math.max(0.1, Math.min(0.9, 0.5 + Math.cos(angle) * radius)),
                        y: Math.max(0.1, Math.min(0.9, 0.5 + Math.sin(angle) * radius))
                    };
                }

                cleanupStale() {
                    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                    for (const [key, data] of this.positions) {
                        if (new Date(data.savedAt).getTime() < thirtyDaysAgo) {
                            this.positions.delete(key);
                            localStorage.removeItem(this.storageKey(key));
                        }
                    }
                }

                clearAll() {
                    for (const key of this.positions.keys()) {
                        localStorage.removeItem(this.storageKey(key));
                    }
                    this.positions.clear();
                }
            }

            // ============================================
            // Visualizer
            // ============================================
            class Visualizer {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d", { alpha: false });
                    this.particles = [];
                    this.sessions = new Map();
                    this.animationId = null;
                    this.isAnimating = false;
                    this.dpr = window.devicePixelRatio || 1;
                    this.resizeTimeout = null;
                    this.sourceOverlay = null; // Set by integration code

                    // Cache canvas dimensions (set by resize())
                    this.width = 0;
                    this.height = 0;

                    this.resize();
                    window.addEventListener("resize", () =>
                        this.throttledResize(),
                    );
                }

                throttledResize() {
                    if (this.resizeTimeout) return;
                    this.resizeTimeout = setTimeout(() => {
                        this.resize();
                        this.resizeTimeout = null;
                    }, 100);
                }

                resize() {
                    // Get the canvas's rendered dimensions (respects CSS flex layout)
                    const rect = this.canvas.getBoundingClientRect();
                    this.width = rect.width;
                    this.height = rect.height;
                    this.dpr = window.devicePixelRatio || 1;

                    // Scale canvas for retina displays
                    this.canvas.width = this.width * this.dpr;
                    this.canvas.height = this.height * this.dpr;
                    this.ctx.scale(this.dpr, this.dpr);

                    // Redraw static elements after resize
                    this.drawStatic();
                }

                drawStatic() {
                    this.drawRadarGrid();
                }

                // Get radar grid geometry (used by both canvas and overlay positioning)
                getRadarGeometry() {
                    const size = Math.min(this.width, this.height);
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;
                    const maxRadius = size * 0.45; // Leave padding for source circles
                    return { size, centerX, centerY, maxRadius };
                }

                drawRadarGrid() {
                    const { ctx } = this;
                    const { centerX, centerY, maxRadius } = this.getRadarGeometry();

                    // Clear canvas
                    ctx.fillStyle = "#00141f";
                    ctx.fillRect(0, 0, this.width, this.height);

                    // Draw concentric circles (distance zones)
                    ctx.strokeStyle = "rgba(42, 42, 58, 0.5)";
                    ctx.lineWidth = 1;
                    [0.25, 0.5, 0.75, 1].forEach(pct => {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, maxRadius * pct, 0, Math.PI * 2);
                        ctx.stroke();
                    });

                    // Draw axis crosshair lines
                    ctx.beginPath();
                    ctx.moveTo(centerX - maxRadius, centerY);
                    ctx.lineTo(centerX + maxRadius, centerY);
                    ctx.moveTo(centerX, centerY - maxRadius);
                    ctx.lineTo(centerX, centerY + maxRadius);
                    ctx.stroke();

                    // Draw listener indicator at center
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Listener label
                    ctx.fillStyle = "rgba(136, 136, 136, 0.7)";
                    ctx.font = "10px var(--font-mono)";
                    ctx.textAlign = "center";
                    ctx.fillText("LISTENER", centerX, centerY + 22);
                }

                addEvent(event, sessionKey = null) {
                    const { color, event_type, tool_name } = event;
                    const { centerX, centerY, maxRadius } = this.getRadarGeometry();

                    // Get particle spawn position from source overlay or fallback to center
                    let x = centerX;
                    let y = centerY;

                    if (sessionKey && this.sourceOverlay) {
                        const source = this.sourceOverlay.sources.get(sessionKey);
                        if (source) {
                            // Convert normalized position to canvas coordinates
                            x = centerX + (source.pos.x - 0.5) * 2 * maxRadius;
                            y = centerY + (source.pos.y - 0.5) * 2 * maxRadius;
                        }
                    }

                    // Particle properties based on event
                    let size = 20;
                    let lifetime = 60;

                    if (event_type === "Stop") {
                        size = 50;
                        lifetime = 120;
                    } else if (
                        event_type === "PreToolUse" ||
                        event_type === "PostToolUse"
                    ) {
                        size = tool_name === "Task" ? 35 : 15;
                        lifetime = 45;
                    }

                    this.particles.push({
                        x,
                        y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size,
                        color: color || "#4ECDC4",
                        alpha: 1,
                        lifetime,
                        maxLifetime: lifetime,
                    });

                    // Start animation if not running
                    if (!this.isAnimating) {
                        this.startAnimation();
                    }
                }

                updateSession(session) {
                    this.sessions.set(session.session_id, session);
                    // Redraw static elements to show new session
                    if (!this.isAnimating) {
                        this.drawStatic();
                    }
                }

                startAnimation() {
                    this.isAnimating = true;
                    this.animate();
                }

                stopAnimation() {
                    this.isAnimating = false;
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                    // Draw final static state
                    this.drawStatic();
                }

                animate() {
                    if (!this.isAnimating) return;

                    const { ctx } = this;

                    // Clear with fade effect
                    ctx.fillStyle = "rgba(0, 20, 31, 0.15)";
                    ctx.fillRect(0, 0, this.width, this.height);

                    // Redraw radar grid (faint, under particles)
                    this.drawRadarGrid();

                    // Update and draw particles
                    let activeParticles = 0;
                    this.particles = this.particles.filter((p) => {
                        p.lifetime--;
                        if (p.lifetime <= 0) return false;

                        activeParticles++;
                        p.alpha = p.lifetime / p.maxLifetime;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.size *= 0.98;

                        const alphaHex = Math.floor(p.alpha * 255)
                            .toString(16)
                            .padStart(2, "0");

                        // Glow effect (drawn first, behind main circle)
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle =
                            p.color +
                            Math.floor(p.alpha * 50)
                                .toString(16)
                                .padStart(2, "0");
                        ctx.fill();

                        // Main particle
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = p.color + alphaHex;
                        ctx.fill();

                        return true;
                    });

                    // Stop animation when no particles
                    if (activeParticles === 0) {
                        this.stopAnimation();
                        return;
                    }

                    this.animationId = requestAnimationFrame(() =>
                        this.animate(),
                    );
                }
            }

            // ============================================
            // Source Overlay (Draggable HTML elements)
            // ============================================
            class SourceOverlay {
                constructor(container, canvas, positionManager, audioEngine) {
                    this.container = container;
                    this.canvas = canvas;
                    this.positionManager = positionManager;
                    this.audioEngine = audioEngine;
                    this.sources = new Map();
                    this.selectedKey = null;
                    this.dragState = null;
                    this.sessionIndex = 0; // Track index for auto-positioning

                    // Global listeners for drag
                    document.addEventListener('pointermove', (e) => this.onPointerMove(e));
                    document.addEventListener('pointerup', (e) => this.onPointerUp(e));

                    // Deselect on container click (not on source)
                    this.container.addEventListener('click', (e) => {
                        if (e.target === this.container || e.target === this.canvas) {
                            this.deselect();
                        }
                    });

                    // Handle window resize
                    window.addEventListener('resize', () => this.repositionAll());
                }

                createSource(session) {
                    const key = `${session.machine_id}:${session.session_id}`;

                    // Skip if already exists
                    if (this.sources.has(key)) {
                        return;
                    }

                    // Get or auto-assign position
                    const index = this.sessionIndex++;
                    const pos = this.positionManager.getPosition(key, index);

                    // Create element
                    const el = document.createElement('div');
                    el.className = 'source-circle';
                    el.dataset.session = key;
                    el.style.setProperty('--session-color', session.color);

                    // Icon and label
                    const icon = document.createElement('div');
                    icon.className = 'source-icon';
                    icon.textContent = '';

                    const label = document.createElement('div');
                    label.className = 'source-label';
                    label.textContent = session.session_id.slice(0, 8);

                    el.appendChild(icon);
                    el.appendChild(label);

                    // Position element
                    this.setElementPosition(el, pos.x, pos.y);

                    // Event listeners
                    el.addEventListener('pointerdown', (e) => this.onPointerDown(e, key));

                    this.container.appendChild(el);
                    this.sources.set(key, { el, pos, session });

                    // Create panner and set initial position
                    this.audioEngine.createPannerForSession(key);
                    this.audioEngine.updatePannerPosition(key, pos.x, pos.y);
                }

                setElementPosition(el, normX, normY) {
                    const rect = this.canvas.getBoundingClientRect();
                    const containerRect = this.container.getBoundingClientRect();
                    const size = Math.min(rect.width, rect.height);
                    const maxRadius = size * 0.45;
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;

                    // Convert normalized (0-1) to pixel position within radar
                    const pixelX = centerX + (normX - 0.5) * 2 * maxRadius;
                    const pixelY = centerY + (normY - 0.5) * 2 * maxRadius;

                    el.style.left = `${pixelX}px`;
                    el.style.top = `${pixelY}px`;
                }

                repositionAll() {
                    for (const [key, source] of this.sources) {
                        this.setElementPosition(source.el, source.pos.x, source.pos.y);
                    }
                }

                onPointerDown(e, key) {
                    e.preventDefault();
                    e.stopPropagation();

                    const source = this.sources.get(key);
                    if (!source) return;

                    // Select this source
                    this.select(key);

                    // Start drag
                    source.el.classList.add('dragging');
                    source.el.setPointerCapture(e.pointerId);

                    this.dragState = {
                        key,
                        pointerId: e.pointerId,
                        startPos: { ...source.pos }
                    };
                }

                onPointerMove(e) {
                    if (!this.dragState) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const size = Math.min(rect.width, rect.height);
                    const maxRadius = size * 0.45;
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;

                    // Calculate position relative to canvas
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;

                    // Convert to normalized coordinates
                    let normX = 0.5 + (canvasX - centerX) / (2 * maxRadius);
                    let normY = 0.5 + (canvasY - centerY) / (2 * maxRadius);

                    // Clamp to bounds (with slight padding from edges)
                    normX = Math.max(0.05, Math.min(0.95, normX));
                    normY = Math.max(0.05, Math.min(0.95, normY));

                    const source = this.sources.get(this.dragState.key);
                    if (source) {
                        source.pos = { x: normX, y: normY };
                        this.setElementPosition(source.el, normX, normY);
                        this.audioEngine.updatePannerPosition(this.dragState.key, normX, normY);
                    }
                }

                onPointerUp(e) {
                    if (!this.dragState) return;

                    const source = this.sources.get(this.dragState.key);
                    if (source) {
                        source.el.classList.remove('dragging');
                        source.el.releasePointerCapture(this.dragState.pointerId);
                        // Save position to localStorage
                        this.positionManager.savePosition(this.dragState.key, source.pos.x, source.pos.y);
                    }

                    this.dragState = null;
                }

                select(key) {
                    // Deselect previous
                    this.deselect();

                    // Select new
                    this.selectedKey = key;
                    const source = this.sources.get(key);
                    if (source) {
                        source.el.classList.add('selected');
                    }
                }

                deselect() {
                    if (this.selectedKey) {
                        const prev = this.sources.get(this.selectedKey);
                        if (prev) {
                            prev.el.classList.remove('selected');
                        }
                        this.selectedKey = null;
                    }
                }

                removeSource(key) {
                    const source = this.sources.get(key);
                    if (!source) return;

                    // Fade out then remove
                    source.el.classList.add('disconnected');
                    setTimeout(() => {
                        source.el.remove();
                        this.sources.delete(key);
                        this.audioEngine.removePannerForSession(key);
                    }, 1000);

                    // Deselect if this was selected
                    if (this.selectedKey === key) {
                        this.selectedKey = null;
                    }
                }

                resetLayout() {
                    this.positionManager.clearAll();
                    this.sessionIndex = 0;

                    // Reposition all sources
                    for (const [key, source] of this.sources) {
                        const pos = this.positionManager.autoAssign(this.sessionIndex++);
                        source.pos = pos;
                        this.setElementPosition(source.el, pos.x, pos.y);
                        this.audioEngine.updatePannerPosition(key, pos.x, pos.y);
                        this.positionManager.savePosition(key, pos.x, pos.y);
                    }
                }
            }

            // ============================================
            // App State & UI
            // ============================================
            let ws = null;
            let audioEngine = new AudioEngine();
            let positionManager = new PositionManager();
            let visualizer = null;
            let sourceOverlay = null;
            const sessions = new Map();
            const eventLog = [];
            const MAX_LOG_ITEMS = 50;

            // Cached DOM references (populated on DOMContentLoaded)
            const DOM = {
                sessionsEl: null,
                logEl: null,
                connectBtn: null,
                statusDot: null,
                statusText: null,
                muteBtn: null,
                volumeInput: null,
                reverbInput: null,
            };

            function updateUI() {
                // Update sessions list using safe DOM methods
                const sessionsEl = DOM.sessionsEl;
                sessionsEl.innerHTML = "";

                if (sessions.size === 0) {
                    sessionsEl.appendChild(
                        createElement(
                            "div",
                            { class: "empty-state", role: "listitem" },
                            ["No active sessions"],
                        ),
                    );
                } else {
                    for (const s of sessions.values()) {
                        const panPercent = ((s.pan + 1) / 2) * 100;
                        const sessionItem = createElement(
                            "div",
                            { class: "session-item", role: "listitem" },
                            [
                                createElement("div", {
                                    class: "session-color",
                                    style: { background: s.color },
                                    "aria-hidden": "true",
                                }),
                                createElement(
                                    "div",
                                    { class: "session-info" },
                                    [
                                        createElement(
                                            "div",
                                            { class: "session-id" },
                                            [s.session_id.slice(0, 12) + "..."],
                                        ),
                                        createElement(
                                            "div",
                                            { class: "session-meta" },
                                            [
                                                `${s.machine_id || "Unknown"}  ${s.event_count || 0} events`,
                                            ],
                                        ),
                                    ],
                                ),
                                createElement(
                                    "div",
                                    {
                                        class: "pan-indicator",
                                        "aria-label": `Pan position: ${Math.round(s.pan * 100)}%`,
                                    },
                                    [
                                        createElement("div", {
                                            class: "pan-dot",
                                            style: {
                                                left: `${panPercent}%`,
                                                background: s.color,
                                            },
                                        }),
                                    ],
                                ),
                            ],
                        );
                        sessionsEl.appendChild(sessionItem);
                    }
                }

                // Update event log using safe DOM methods
                const logEl = DOM.logEl;
                logEl.innerHTML = "";

                if (eventLog.length === 0) {
                    logEl.appendChild(
                        createElement("div", { class: "empty-state" }, [
                            "Waiting for events...",
                        ]),
                    );
                } else {
                    const recentEvents = eventLog
                        .slice(-MAX_LOG_ITEMS)
                        .reverse();
                    for (const e of recentEvents) {
                        const eventChildren = [
                            createElement("span", { class: "event-type" }, [
                                e.event_type || "Unknown",
                            ]),
                        ];
                        if (e.tool_name) {
                            eventChildren.push(
                                createElement("span", { class: "event-tool" }, [
                                    e.tool_name,
                                ]),
                            );
                        }
                        eventChildren.push(
                            createElement("span", { class: "event-time" }, [
                                e.timestamp
                                    ? new Date(e.timestamp).toLocaleTimeString()
                                    : "",
                            ]),
                        );
                        logEl.appendChild(
                            createElement(
                                "div",
                                { class: "event-item" },
                                eventChildren,
                            ),
                        );
                    }
                }
            }

            function handleEvent(event) {
                const sessionKey = event.machine_id && event.session_id
                    ? `${event.machine_id}:${event.session_id}`
                    : null;

                // Update session tracking
                if (event.session_id) {
                    const sessionData = {
                        session_id: event.session_id,
                        machine_id: event.machine_id,
                        pan: event.pan,
                        color: event.color,
                        event_count:
                            (sessions.get(event.session_id)?.event_count || 0) +
                            1,
                    };
                    sessions.set(event.session_id, sessionData);
                    visualizer?.updateSession(sessionData);

                    // Create source overlay if not exists
                    if (sourceOverlay && sessionKey) {
                        sourceOverlay.createSource(sessionData);
                    }
                }

                // Add to log
                eventLog.push(event);
                if (eventLog.length > MAX_LOG_ITEMS * 2) {
                    eventLog.splice(0, MAX_LOG_ITEMS);
                }

                // Play sound
                audioEngine.playEvent(event);

                // Visualize (pass sessionKey for particle positioning)
                visualizer?.addEvent(event, sessionKey);

                // Update UI
                updateUI();
            }

            let audioInitFailed = false;

            async function connect() {
                const {
                    connectBtn: btn,
                    statusDot: dot,
                    statusText: text,
                    muteBtn,
                } = DOM;

                btn.disabled = true;
                btn.textContent = "Connecting...";
                dot.setAttribute("aria-label", "Connection status: connecting");

                try {
                    // Initialize audio (requires user gesture)
                    try {
                        await audioEngine.init();
                        audioInitFailed = false;
                    } catch (audioErr) {
                        audioInitFailed = true;
                        // Continue without audio - show warning but don't block connection
                        muteBtn.textContent = "Audio unavailable";
                        muteBtn.disabled = true;
                        muteBtn.setAttribute("aria-disabled", "true");
                    }

                    ws = new WebSocket(WS_URL);

                    ws.onopen = () => {
                        dot.classList.add("connected");
                        dot.setAttribute(
                            "aria-label",
                            "Connection status: connected",
                        );
                        text.textContent = audioInitFailed
                            ? "Connected (no audio)"
                            : "Connected";
                        btn.textContent = "Disconnect";
                        btn.disabled = false;
                    };

                    ws.onmessage = (msg) => {
                        try {
                            const data = JSON.parse(msg.data);

                            // Handle init message with existing sessions
                            if (data.type === "init" && data.sessions) {
                                data.sessions.forEach((s) => {
                                    sessions.set(s.session_id, s);
                                    visualizer?.updateSession(s);
                                    // Create source overlay for existing session
                                    if (sourceOverlay) {
                                        sourceOverlay.createSource(s);
                                    }
                                });
                                updateUI();
                                return;
                            }

                            // Handle regular event
                            handleEvent(data);
                        } catch (err) {
                            // Silently handle parse errors for malformed messages
                        }
                    };

                    ws.onclose = () => {
                        dot.classList.remove("connected");
                        dot.setAttribute(
                            "aria-label",
                            "Connection status: disconnected",
                        );
                        text.textContent = "Disconnected";
                        btn.textContent = "Connect";
                        btn.disabled = false;
                        ws = null;
                    };

                    ws.onerror = () => {
                        dot.setAttribute(
                            "aria-label",
                            "Connection status: error",
                        );
                        text.textContent = "Connection failed";
                        btn.textContent = "Retry";
                        btn.disabled = false;
                    };
                } catch (err) {
                    dot.setAttribute("aria-label", "Connection status: error");
                    text.textContent = "Connection failed";
                    btn.textContent = "Retry";
                    btn.disabled = false;
                }
            }

            function disconnect() {
                if (ws) {
                    ws.close();
                    ws = null;
                }
            }

            // ============================================
            // Initialize
            // ============================================
            document.addEventListener("DOMContentLoaded", () => {
                // Cache DOM references
                DOM.sessionsEl = document.getElementById("sessions-list");
                DOM.logEl = document.getElementById("event-log");
                DOM.connectBtn = document.getElementById("connect-btn");
                DOM.statusDot = document.getElementById("status-dot");
                DOM.statusText = document.getElementById("status-text");
                DOM.muteBtn = document.getElementById("mute-btn");
                DOM.volumeInput = document.getElementById("volume");
                DOM.reverbInput = document.getElementById("reverb");

                // Initialize visualizer
                const canvas = document.getElementById("visualizer");
                const spatialContainer = document.getElementById("spatial-container");
                visualizer = new Visualizer(canvas);

                // Initialize source overlay
                sourceOverlay = new SourceOverlay(
                    spatialContainer,
                    canvas,
                    positionManager,
                    audioEngine
                );
                visualizer.sourceOverlay = sourceOverlay;

                // Connect button
                DOM.connectBtn.addEventListener("click", () => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        disconnect();
                    } else {
                        connect();
                    }
                });

                // Volume control
                DOM.volumeInput.addEventListener("input", (e) => {
                    audioEngine.setVolume(e.target.value / 100);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                });

                // Reverb control
                DOM.reverbInput.addEventListener("input", (e) => {
                    audioEngine.setReverb(e.target.value / 100);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                });

                // Mute button
                DOM.muteBtn.addEventListener("click", (e) => {
                    const muted = audioEngine.toggleMute();
                    e.target.textContent = muted ? "Unmute" : "Mute";
                    e.target.classList.toggle("muted", muted);
                    e.target.setAttribute("aria-pressed", muted);
                });

                // Reset layout button
                document.getElementById("reset-layout-btn").addEventListener("click", () => {
                    if (sourceOverlay) {
                        sourceOverlay.resetLayout();
                    }
                });
            });
        </script>
    </body>
</html>
